//我想大部分人都知道，通常一个程序员会具有的美德。当然了，有三种：懒惰、暴躁、傲慢。
//一个人写的烂软件将会给另一个人带来一份全职工作。
//除非我不想赢，否则没有人能让我输！！！
//一鼓作气，考研是一种忍耐！！！
#define _CRT_SECURE_NO_WARNINGS 1 
#include <stdio.h>
/*
什么是递归？
程序调用自身的编程技巧称为递归（ recursion）。
递归做为一种算法在程序设计语言中广泛应用。 一个过程或函数在其定义或说明中有直接或间接
调用自身的
一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，
递归策略
只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。
递归的主要思考方式在于：把大事化小


 递归的两个必要条件
·存在限制条件，当满足这个限制条件的时候，递归便不再继续。
·每次递归调用之后越来越接近这个限制条件。
*/


//int main()
//{
//	printf("hehe\n");
//	main();//main函数中调用main函数
//	return 0;//死循环输出hehe，像栈空间申请存放hehe，程序终止--内存空间不足--栈溢出
//}
//递归常见错误，栈溢出
//申请的内存空间分为栈区（局部变量、函数形参），堆区（动态开辟的内存），静态区（全局变量static修饰的变量）


//练习1：（画图讲解）
//接受一个整型值（无符号），按照顺序打印它的每一位。
//例如：
//输入：1234，输出 1 2 3 4

//void print(int n)
//{
//	if (n > 9)//两位数以上
//	{
//		print(n / 10);//调用print函数
//	}
//	printf("%d ", n % 10);
//}
//int main()
//{
//	unsigned int num = 0;
//	scanf("%d", &num);//1234
//	//递归
//	print(num);//函数调用
//	//print(1234)
//	//print(123)   4
//	//print(12)  3 4
//	//print(1) 2 3 4
//	return 0;
//}


//练习2：（画图讲解）
//编写函数不允许创建临时变量，求字符串的长度
#include <string.h>
//my_strlen(char* str)//str - 指针变量
//{
//	int count = 0;
//	while(*str != '\0')//字符串的结束标志\n
//	{
//		count++;
//		str++;//指针加一，即下一个字符b-->i-->t-->\0
//	}
//	return count;
//}



//不允许创建临时变量
//int my_strlen(char* str)
//{
//	if (*str != '\0')
//		return 1 + my_strlen(str + 1);
//	else
//		return 0;//如果第一个字符就是\0，那么长度就是0
//}
////my_strlrn("bit");
////1+my_strlrn("it");
////1+1+my_strlrn("t");
////1+1+1+my_strlrn("\n");
////1+1+1+0;
////3;
//int main()
//{
//	char arr[] = "bit";
//	//int len = strlen(arr);//求字符串长度
//	//printf("%d\n", len);
//	//模拟实现了一个strlen函数
//	int len = my_strlen(arr);//arr是数组，数组传参传过去的不是整个数组，而是首元素的地址
//	printf("len = %d\n", len);
//	return 0;
//}

//-------------------------------------------------------------------------------------------------------------
//递归与迭代
//练习3： 求n的阶乘。（不考虑溢出）
//int Fac1(int n)
//{
//	int i = 0;
//	int ret = 1;
//	for (i = 1; i <= n; i++)
//	{
//		ret *= i;
//	}
//	return ret;
//}
//int Fac2(int n)
//{
//	if (n <= 1)
//		return 1;
//	else
//		return n * Fac2(n - 1);
//}
//int main()
//{
//	//求n的阶乘
//	int n = 0;
//	int ret = 0;
//	scanf("%d", &n);
//	//ret = Fac1(n);
//	ret = Fac2(n);
//	printf("%d\n", ret);//循环的方式
//	return 0;
//}


//练习4：
//求第n个斐波那契数。（不考虑溢出）
//int count = 0;
//int Fib(int n)
//{
//	if (n == 3)
//	{
//		count++;//计算一次3的斐波那契数列，就+1
//	}
//	if (n <= 2)
//		return 1;
//	else
//		return Fib(n - 1) + Fib(n - 2);
//}
/*
但是我们发现有问题；
在使用 fib 这个函数的时候如果我们要计算第50个斐波那契数字的时候特别耗费时间。
使用 factorial 函数求10000的阶乘（不考虑结果的正确性），程序会崩溃。
那我们如何改进呢？
在调试 factorial 函数的时候，如果你的参数比较大，那就会报错： stack overflow（栈溢出）
这样的信息。
系统分配给程序的栈空间是有限的，但是如果出现了死循环，或者（死递归），这样有可能导致一
直开辟栈空间，最终产生栈空间耗尽的情况，这样的现象我们称为栈溢出
*/
//50
//49 48
//48 47 47 46
//47 46 46 45 46 45 45 44
//计算过大的数，很多数要重复计算，效率太低 - 迭代

//int Fib(int n)
//{
//	int a = 1;
//	int b = 1;
//	int c = 1;//因为n=1和n=2时的值是1，所以int c=1,而不是int c =0;
//	while (n > 2)
//	{
//		c = a + b;
//		a = b;
//		b = c;
//		n--;
//	}
//	return c;
//}
//int main()
//{
//	int n = 0;
//	int ret = 0;
//	scanf("%d", &n);
//	//TDD - 测试驱动开发 - 先写用处，再定义函数功能
//	ret = Fib(n);
//	printf("ret = %d\n", ret);
//	/*printf("ret = %d\n", count);*/
//	return 0;
//}


/*
那如何解决上述的问题：
1. 将递归改写成非递归。
2. 使用static对象替代 nonstatic 局部对象。在递归函数设计中，可以使用 static 对象替代
nonstatic 局部对象（即栈对象），这不
仅可以减少每次递归调用和返回时产生和释放 nonstatic 对象的开销，而且 static 对象还可以保
存递归调用的中间状态，并且可为
各个调用层所访问。
提示：
1. 许多问题是以递归的形式进行解释的，这只是因为它比非递归的形式更为清晰。
2. 但是这些问题的迭代实现往往比递归实现效率更高，虽然代码的可读性稍微差些。
3. 当一个问题相当复杂，难以用迭代实现时，此时递归实现的简洁性便可以补偿它所带来的运行时开
销
*/