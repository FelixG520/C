//我想大部分人都知道，通常一个程序员会具有的美德。当然了，有三种：懒惰、暴躁、傲慢。
//一个人写的烂软件将会给另一个人带来一份全职工作。
//除非我不想赢，否则没有人能让我输！！！
//一鼓作气，考研是一种忍耐！！！
#define _CRT_SECURE_NO_WARNINGS 1 
#include <stdio.h>
/*
表达式求值
表达式求值的顺序一部分是由操作符的优先级和结合性决定。
同样，有些表达式的操作数在求值的过程中可能需要转换为其他类型。
*/ 

/*
隐式类型转换
C的整型算术运算总是至少以缺省整型类型的精度来进行的。
为了获得这个精度，表达式中的字符和短整型操作数在使用之前被转换为普通整型，这种转换称为整型提升。
//实例1
char a, b, c;
...
a = b + c;
b和c的值被提升为普通整型，然后再执行加法运算
加法运算完成之后，结果将被截断，然后再存储于a中。 
*/

//int main()
//{
//	char a = 3;//3是一个整型 - 00000000000000000000000000000011，但是char是字符类型，只能放一个字节，即八个比特位，因此要发生截断 - 截最低位字节
//	//00000000000000000000000000000011
//	//00000011 - a
//	char b = 127;
//	//00000000000000000000000001111111
//	//01111111 - b
//	char c = a + b;//b和c的值被提升为普通整型，然后再执行加法运算
//	//如何进行整体提升呢？
//	//整形提升是按照变量的数据类型的符号位来提升的
//	//a - 00000011 -> 00000000000000000000000000000011 - 符号位是0就全补0
//	//b - 01111111 -> 00000000000000000000000001111111
//	//a + b = 00000000000000000000000010000010 - 截断 - 10000010
//	//10000010 - c
//	//11111111111111111111111110000010 - 符号位是1就全补1 - 计算机存储的是补码
//	//11111111111111111111111110000010 - 补码
//	//11111111111111111111111110000001 - 反码
//	//10000000000000000000000001111110 - 原码 - -126
//	printf("%d\n", c);//%d是打印整型，因此要将char c提升成整型
//	return 0;
//}

/*
整型提升的意义：
表达式的整型运算要在CPU的相应运算器件内执行，CPU内整型运算器(ALU)的操作数的字节长度
一般就是int的字节长度，同时也是CPU的通用寄存器的长度。
因此，即使两个char类型的相加，在CPU执行时实际上也要先转换为CPU内整型操作数的标准长
度。
通用CPU（general - purpose CPU）是难以直接实现两个8比特字节直接相加运算（虽然机器指令
中可能有这种字节相加指令）。所以，表达式中各种长度可能小于int长度的整型值，都必须先转
换为int或unsigned int，然后才能送入CPU去执行运算
*/ 


//整形提升的例子:
//实例1
//int main()
//{
//	char a = 0xb6;//b6 - 10110110 - 11111111111111111111111110110110
//	short b = 0xb600;
//	int c = 0xb6000000;
//	if (a == 0xb6)//11111111111111111111111110110110 ！= b6
//		printf("a");
//	if (b == 0xb600)
//		printf("b");
//	if (c == 0xb6000000)
//		printf("c");
//	return 0;
//}
/*
a, b要进行整形提升, 但是c不需要整形提升
a, b整形提升之后, 变成了负数, 所以表达式 a == 0xb6, b == 0xb600 的结果是假, 但是c不发生整形提升, 则表
达式 c == 0xb6000000 的结果是真
*/


//实例2
//int main()
//{
//	char c = 1;
//	printf("%u\n", sizeof(c));
//	printf("%u\n", sizeof(+c));
//	printf("%u\n", sizeof(-c));
//	return 0;
//}

/*
c只要参与表达式运算, 就会发生整形提升, 表达式 + c, 就会发生提升, 所以 sizeof(+c) 是4个字节.
表达式 - c 也会发生整形提升, 所以 sizeof(-c) 是4个字节, 但是 sizeof(c), 就是1个字节.
*/

//------------------------------------------------------------------------------
//算术转换
/*
如果某个操作符的各个操作数属于不同的类型，那么除非其中一个操作数的转换为另一个操作数的类
型，否则操作就无法进行。下面的层次体系称为寻常算术转换
long double
double
float
unsigned long int
long int
unsigned int
int
如果某个操作数的类型在上面这个列表中排名较低，那么首先要转换为另外一个操作数的类型后执行运算。
警告：
但是算术转换要合理，一般范围小的类型转换为范围大的类型，要不然会有一些潜在的问题。
*/


//---------------------------------------------------------------------------------------------------
/*
操作符的属性
复杂表达式的求值有三个影响的因素。
1. 操作符的优先级
2. 操作符的结合性
3. 是否控制求值顺序。
两个相邻的操作符先执行哪个？取决于他们的优先级。如果两者的优先级相同，取决于他们的结合性。
操作符优先级
*/ 

//int main()
//{
//	int a = 10;
//	int b = 20;
//	int c = b + a*3;//由于*比+的优先级高，只能保证，*的计算是比+早
//	return 0;
//}

/*
表达式的求值部分由操作符的优先级决定。
表达式1 
a*b + c*d + e*f
注释：代码1在计算的时候，由于 * 比 + 的优先级高，只能保证， * 的计算是比 + 早，但是优先级并不
能决定第三个 * 比第一个 + 早执行。
所以表达式的计算机顺序就可能是：
a * b 
c * d 
a * b + c * d 
e * f 
a * b + c * d + e * f
或者：
a * b 
c * d 
e * f 
a * b + c * d 
a * b + c * d + e * f

表达式2 
c + --c;
注释：同上，操作符的优先级只能决定自减--的运算在+的运算的前面，但是我们并没有办法得
知，+操作符的左操作数的获取在右操作数之前还是之后求值，所以结果是不可预测的，是有歧义的
*/ 
//代码3-非法表达式
//int main()
//{
//	int i = 10;
//	i = i-- - --i * (i = -3) * i++ + ++i;
//	printf("i = %d\n", i);
//	return 0;
//}
//表达式3在不同编译器中测试结果：非法表达式程序的结果


//代码4
//int fun()
//{
//	static int count = 1;
//	return ++count;
//}
//int main()
//{
//	int answer;
//	answer = fun() - fun() * fun();
//	printf("%d\n", answer);//输出多少？
//	return 0;
//}
/*
这个代码有没有实际的问题？
有问题！
虽然在大多数的编译器上求得结果都是相同的。
但是上述代码 answer = fun() - fun() * fun(); 中我们只能通过操作符的优先级得知：先算乘法，
再算减法。
函数的调用先后顺序无法通过操作符的优先级确定。
*/ 


//代码5
#include <stdio.h>
int main()
{
	int i = 1;
	int ret = (++i) + (++i) + (++i);
	printf("%d\n", ret);
	printf("%d\n", i);
	return 0;
}
/*
尝试在linux 环境gcc编译器，VS2013环境下都执行，看结果。
这段代码中的第一个 + 在执行的时候，第三个++是否执行，这个是不确定的，因为依靠操作符的优先级
和结合性是无法决定第一个 + 和第
三个前置 ++ 的先后顺序。
总结：我们写出的表达式如果不能通过操作符的属性确定唯一的计算路径，那这个表达式就是存在问题
的
*/