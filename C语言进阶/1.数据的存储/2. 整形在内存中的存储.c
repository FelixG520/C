#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
/*
int main()
{
	int a = 20;  //4个字节 - 32bit 14 00 00 00
	//00000000000000000000000000010100 - 原码
	//00000000000000000000000000010100 - 反码
	//00000000000000000000000000010100 - 补码
	//0   0   0   0   0   0   1   4   - 转化成16进制
	int b = -10; //f6 ff ff ff
	//10000000000000000000000000001010 - 原码
	//11111111111111111111111111110101 - 反码
	//11111111111111111111111111110110 - 补码
	//f   f   f   f   f   f   f   6   - 转化成16进制
	return 0;
}
*/


/*
原码、反码、补码
	计算机中的整数有三种表示方法，即原码、反码和补码。
	三种表示方法均有符号位和数值位两部分，符号位都是用0表示“正”，用1表示“负”，而数值位
	负整数的三种表示方法各不相同。

	原码
		直接将二进制按照正负数的形式翻译成二进制就可以。
	反码
		将原码的符号位不变，其他位依次按位取反就可以得到了。
	补码
		反码 + 1就得到补码。

	正数的原、反、补码都相同。

	对于整形来说：数据存放内存中其实存放的是补码。

	为什么呢？
		在计算机系统中，数值一律用补码来表示和存储。原因在于，使用补码，可以将符号位和数值域统一处理；
		同时，加法和减法也可以统一处理（CPU只有加法器）此外，补码与原码相互转换，其运算过程
		是相同的，不需要额外的硬件电路.


		整数：1.有符号数：正数：原码、反码、补码相同
		                  负数：原码、反码、补码不同，要进行计算

		      2.无符号数：原码、反码、补码相同
*/


/*
int main()
{
	1 - 1;
	//原码计算，明显错误
	//1+(-1)
	//1: 00000000000000000000000000000001
	//-1:10000000000000000000000000000001
	//1+(-1):10000000000000000000000000000010

	//补码计算，正确
	//1补码: 00000000000000000000000000000001
	//-1反码:11111111111111111111111111111110
	//-1补码:11111111111111111111111111111111
	//1+(-1):100000000000000000000000000000000
	//只能存32位，就把1丢了00000000000000000000000000000000
	return 0;
}
*/

/*
我们可以看到对于a和b分别存储的是补码。但是我们发现顺序有点不对劲。
20: 0x 00 00 00 14
int a = 20;  //14 00 00 00
-10:0x ff ff ff f6
int b = -10; //f6 ff ff ff

大小端介绍
	什么大端小端：
		大端（存储）模式，是指数据的低位保存在内存的高地址中，而数据的高位，保存在内存的低地址中；
		小端（存储）模式，是指数据的低位保存在内存的低地址中，而数据的高位，保存在内存的高地址中。
	为什么有大端和小端：
		为什么会有大小端模式之分呢？这是因为在计算机系统中，我们是以字节为单位的，每个地址单元
		都对应着一个字节，一个字节为8bit。但是在C语言中除了8 bit的char之外，还有16 bit的short型，32 bit的long型（要看具体的编
		译器），另外，对于位数大于8位的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个如何将多个字节安排的问题。
		因此就导致了大端存储模式和小端存储模式。
		例如：一个 16bit 的short型x，在内存中的地址为 0x0010 ，x的值为 0x1122，那么 0x11为高字节，0x22 为低字节。
		对于大端模式，就将0x11放在低地址中，即 0x0010 中， 0x22 放在高地址中，即 0x0011 中。小端模式，刚好相反。
		我们常用的 X86 结构是小端模式，而KEIL C51 则为大端模式。很多的ARM，DSP都为小端模式。有些ARM处理器还可以
		由硬件来选择是大端模式还是小端模式。
*/

/*
int main()
{
	//小端存储
	int a = 0x11223344;//44 33 22 11
	return 0;
}
*/


/*
百度2015年系统工程师笔试题：
请简述大端字节序和小端字节序的概念，设计一个小程序来判断当前机器的字节序。（10分）
*/

//int main()
//{
//	int a = 1;
//	//char* p =  & a;// 从“int *”到“char *”的类型不兼容
//	char* p = (char*)&a;
//	if (*p == 1)
//	{
//		printf("小端\n");
//	}
//	else
//	{
//		printf("大端\n");
//	}
//	return 0;
//}

/*
check_sys()
{
	int a = 1;
	char* p = (char*)&a;
	//返回1，小端  返回0，大端
	return *p;
	//return *(char*)&a;
}
int main()
{
	//返回1，小端
	//返回0，大端
	int ret = check_sys();
	if (ret == 1)
	{
		printf("小端\n");
	}
	else
	{
		printf("大端\n");
	}
	return 0;
}
*/


//指针类型的意义
//1.指针类型决定了指针解引用操作符能访问几个字节 char* p; *p访问了一个字节；int* p; *p访问四个字节
//2.指针类型决定了指针+1、-1到底加的或者减的是几个字节，char * p; p+1跳过了一个字节；int* p; p+1跳过四个字节

//练习
//输出什么？


//1.
//#include <stdio.h>
//int main()
//{
//	char a = -1;
//	//-1 -> 10000001 -> 11111110 -> 111111111
//	signed char b = -1;
//	//111111111
//	unsigned char c = -1;
//	//111111111
//	printf("a=%d,b=%d,c=%d", a, b, c);//整型提升：char只是8个比特位，%d是int32个比特位，所以char前面得补24个比特位，才能输出int，补的时候要看符号位，首位符号位是1就24个都补1，首位是0就24个都补0
//	//%d - 打印十进制有符号数字
//	//整型提升
//	//a - 11111111111111111111111111111111
//	//b - 11111111111111111111111111111111
//	//c - 00000000000000000000000011111111 - 原反补相同 - 255
//
//	return 0;
//}

//2.
//int main()
//{
//	char a = -128;
//	//整型提升补符号位1
//	//10000000000000000000000010000000
//	//11111111111111111111111101111111
//	//110000000 ->截断 10000000 默认为-128
//	//11111111111111111111111110000000 - 无符号数字 - 原反补相同
//	printf("%u\n", a);//有符号数，按无符号数打印
//	//%u - 打印十进制无符号数字
//	return 0;
//}

//有符号的char的范围：-128~127
//无符号的char的范围：0~255

//3.
//#include <Windows.h>
//int main()
//{
//	char a = 128;//127+1 01111111 -> 10000000和-128一样
//	printf("%u\n", a);//有符号数，按无符号数打印
//
//
////4.
//	int i = -20;
//	//10000000 00000000 00000000 00010100
//	//11111111 11111111 11111111 11101011
//	//11111111 11111111 11111111 11101100 - -20补码
//	unsigned int j = 10;
//	//00000000 00000000 00000000 00001010 - 10补码
//	printf("%d\n", i + j);
//	//11111111 11111111 11111111 11110110 - i+j补码
//	//按照补码的形式进行运算，最后格式化成为有符号整数
//	//11111111 11111111 11111111 11110101
//	//10000000 00000000 00000000 00001010 - i+j原码 - -10
//
//
////5.
//	unsigned int k;
//	for (k = 9; k >= 0; k--)//因为是无符号整型，所以9一直减下去也不会小于0；条件不成立，一直循环
//	{
//		printf("%u\n", k);//9~0  2^32-1~0
//		//先算出-1的补码，然后无符号数原反补相同
//		//10000000 00000000 00000000 00000001
//		//11111111 11111111 11111111 11111110
//		//11111111 11111111 11111111 11111111 - 原反补相同 - 2^32-1
//		Sleep(100);
//	}
//	return 0;
//}

//6.
//int main()
//{
//	char a[1000];
//	int i;
//	for (i = 0; i < 1000; i++)
//	{
//		a[i] = -1 - i;//char的范围-128~127
//	}
//	printf("%d", strlen(a));//找到\0停，\0的ASCII码值是0
//	//-1 -2...-128 127 126...1 0    128+127=255个数字
//	return 0;
//}

//7.
//#include <stdio.h>
//unsigned char i = 0;//unsigned char的范围0~255
//int main()
//{
//	for (i = 0; i <= 255; i++)//255+1=256 -> 0 死循环
//	{
//		printf("hello world\n");
//	}
//	return 0;
//}