#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>

//笔试题1
//int main()
//{
//	int a[5] = { 1, 2, 3, 4, 5 };
//	int* ptr = (int*)(&a + 1);
//	printf("%d,%d", *(a + 1), *(ptr - 1));//ptr - 1向前挪动一个整形5的地址，再解引用 -- 5
//	return 0;
//}
//程序的结果是什么？  2  5




//笔试题2
//由于还没学习结构体，这里告知结构体的大小是20个字节
//struct Test
//{
//	int Num;
//	char* pcName;
//	short sDate;
//	char cha[2];
//	short sBa[4];
//}*p;
//假设p 的值为0x100000。 如下表表达式的值分别为多少？
//已知，结构体Test类型的变量大小是20个字节
//int main()
//{
//	p = (struct Test*)0x100000;//初始化p的值为0x100000
//	printf("%p\n", p + 0x1);//结构体类型指针+1跳过一个结构体，跳过20个字节
//	printf("%p\n", (unsigned long)p + 0x1);//unsigned long把p转化成整型1048576+1=1048767 --> 转成16进制0x100001
//	printf("%p\n", (unsigned int*)p + 0x1);//无符号的整形指针+1，跳过一个无符号整型 --4个字节 --> 0x100004
//	return 0;
//}
//指针 + -整数
//int main()
//{
//	int a = 0x11223344;
//	int* pa = &a;
//	char* pc = &a;
//	printf("%p\n", pa);    //000000906DEFFB34
//	printf("%p\n", pa + 1);//000000906DEFFB38 - 整型类型+1跳过4个字节
//	printf("%p\n", pc);    //000000906DEFFB34
//	printf("%p\n", pc + 1);//000000906DEFFB35 - 字符类型+1跳过1个字节
//	return 0;
//}
//总结：指针的类型决定了指针向前或者向后走一步有多大（距离）
/*
int*p p+1 --> 4
char*p p+1 --> 1
double*p p+1 --> 8
*/



//笔试题3
//int main()
//{
//	int a[4] = { 1, 2, 3, 4 };
//	int* ptr1 = (int *)(&a + 1);//强制类型转化为int，整形+1就是+1，地址往后偏移1
//	int* ptr2 = (int *)((int)a + 1);//a首元素地址，迁至类型转化成整形+1，仍然是个整数，又强制转化成指针，由于整形的时候+1，相当于跟不加向后偏移了一个字节
//	printf("%x,%x", ptr1[-1], *ptr2);//打印16进制，ptr1[-1] == *(ptr+(-1)) == *(ptr-1) -- 4     *ptr2的16进制00 00 00|02 --> 大端存储02 00 00 00
//	//小端存储 |01 00 00 00|02 00 00 00|03 00 00 00|04 00 00 00|
//	//         a   (int)a + 1                    ptr-1         ptr //
//	return 0;
//
//}

//笔试题4
//int main()
//{
//	int a[3][2] = { (0, 1), (2, 3), (4, 5) };//圆括号里逗号表达式是最后一个元素1，3，5，0，0，0
//	int* p = a[0];// a[0]是第一行的数组名，数组名是首元素地址 -- 1的地址
//	printf("%d %d %d %d", *p,p[0],p[1],p[2]);//p[0] == *(p + 0)  类比a[0]和arr都是数组名，arr[0] == a[0][0]
//	return 0;          //*(p + i)既然是数组名，* (p + i) == p[i], (*(p + i))[j]) == p[i][j]
//}


//笔试题5
int main()
{
	int a[5][5];
	int(*p)[4];//数组指针，所指向的数组有4个元素
	p = a;//第一行的地址a的类型int(*)[5]，p的类型int(*)[4],把地址赋给了p，只是类型不符而已
	printf("%p,%d\n", &p[4][2] - &a[4][2], &p[4][2] - &a[4][2]);//p[4][2] == *(*(p + 4) + 2)   地址相减，表示相差元素个数，低地址减高地址 -- -4(%p --FFFFFFFC(-4的补码) %d -- -4)
	//    a[0]        a[1]        a[2]        a[3]        a[4]
	//| 0 0 0 0 0 | 0 0 0 0 0 | 0 0 0 0 0 | 0 0 0 0 0 | 0 0 0 0 0 |
	//  p+0     p+1       p+2       p+3       p+4           a[4][2]
	// 
	//     | 0            0            0          0           0 |
	//                *(p + 4)            *(*(p + 4) + 2)
	//
	//-4 原码 10000000 00000000 00000000 00000100
	//   反码 11111111 11111111 11111111 11111011
	//   补码 11111111 11111111 11111111 11111100 -- 地址是无符号数，把补码当原码 -- FFFFFFFC
	return 0;
}