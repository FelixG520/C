#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
/*
3.1 数组指针的定义
数组指针是指针？还是数组？
答案是：指针。
我们已经熟悉：
整形指针： int* pint; 能够指向整形数据的指针。
浮点型指针： float* pf; 能够指向浮点型数据的指针。
那数组指针应该是：能够指向数组的指针。
下面代码哪个是数组指针？
*/   


//int main()
//{
//	int* p = NULL;//整形指针 -- 指向整型的指针 -- 存放整形的地址
//	char* pc = NULL;//pc是字符指针 -- 指向字符的指针 -- 存放字符的地址
//	
//	
//	//数组指针 -- 指向数组的指针 -- 存放数组的地址
//	int arr[10] = {1,2,3,4,5,6,7,8,9,10 };
//	//arr - 首元素地址
//	//&arr[0] - 首元素地址
//	//&arr - 数组的地址
//	int (*p)[10] = &arr;//数组地址存起来
//	//p就是数组指针 -- 定义变量时*p不是解引用操作
//
//
//
//	char* arr1[5];
//	char* (*pa)[5] = &arr1;
//	//pa -- 指针变量名 * -- 说明是pa指针 [5] -- 说明pa指向的数组有5个元素  char* -- pa指向的数组的元素类型是char*
//	
//	int arr3[10] = { 0 };
//	int(*pa2)[10] = &arr3;
//	return 0;
//}

//int main()
//{
//	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
//	int(*pa)[10] = &arr;
//	int i = 0;
//	for (i = 0; i < 10; i++)
//	{
//		printf("%d ", (*pa)[i]);
//		printf("%d ", *(*pa + i));//*pa == arr,表示首元素地址
//	}
//	return 0;
//}

//int main()
//{
//	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
//	int* p = arr;
//	int i = 0;
//	for (i = 0; i < 10; i++)
//	{
//		printf("%d ", *(p + i));
//	}
//	return 0;
//}

////参数是数组的形式
//void print1(int arr[3][5], int x, int y)
//{
//	int i, j;
//	for (i = 0; i < x; i++)
//	{
//		for (j = 0; j < y; j++)
//		{
//			printf("%d ", arr[i][j]);
//		}
//		printf("\n");
//	}
//	
//}
////参数是指针的形式
//void print2(int(*p)[5], int x, int y)
//{
//	int i,j;
//	for (i = 0; i < x; i++)
//	{
//		for (j = 0; j < y; j++)
//		{
//			//p是一个数组地址，p+1是下一行的地址，*解引用之后才是数组名
//			printf("%d ", *(*(p + i) + j));//p+i行的第j个元素,*(p + i)相当于找到了这一行的数组名
//			printf("%d ", *(p[i] + j));
//			printf("%d ", (*(p + i))[j]);//* (p + i)既然是数组名，*(p+i) == p[i],(* (p + i))[j]) == p[i][j]
//			printf("%d ", p[i][j]);//*(p+i) == p[i],*(*(p + i) + j) == p[i][j]
//			//（p+i）就是指针在二维数组中行的移动，*（p+i)找到的是第一行这个一维数组的地址，不要忘了，数组的地址和数组首元素地址大小是一样的，*（p+i）+j，就是在这个一维数组里面移动，最后再取值。
//			
//			
//		}
//		printf("\n");
//	}
//}
//int main()
//{
//	int arr[3][5] = { {1,2,3,4,5},{2,3,4,5,6},{3,4,5,6,7} };
//	//数组名就是首元素地址（除了取地址数组名和sizeof数组名）
//	print1(arr,3,5);//当是二维数组时，把arr想象成一维数组，此时每行是一个元素，因此arr有3个元素
//	//第一行就是二维数组首元素，arr是第一行的地址，而第一行又是一个一维数组
//	print2(arr,3,5);
//	return 0;
//}

//int main()
//{
//	int i,arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
//	int* p = arr;
//	for (i = 0; i < 10; i++)
//	{
//		printf("%d ", *(p + i));
//		printf("%d ", *(arr + i));
//		printf("%d ", arr[i]);//arr[i] == *(arr + 1) == *(p + i) == p[i]
//		printf("%d ", p[i]);
//	}
//	return 0;
//}

//int arr[5];//arr是一个5个元素的整型数组
//int* parr1[10];//parr1是一个数组，数组有10个元素，每个元素的类型是int*,parr1是指针数组
//int(*parr2)[10];//parr2是一个数组，数组有10个元素,每个元素的类型是int,parr2是数组指针
//int(*parr3[10])[5];//parr3是一个数组,数组有10个元素,每个元素是数组指针，这个指针可以指向5个元素的数组，每个元素类型为int





//#include <stdio.h>
//int main()
//{
//	int arr[10] = { 0 };
//	printf("arr = %p\n", arr);
//	printf("&arr= %p\n", &arr);
//	printf("arr+1 = %p\n", arr + 1);
//	printf("&arr+1= %p\n", &arr + 1);
//	return 0;
//}
/*
根据上面的代码我们发现，其实&arr和arr，虽然值是一样的，但是意义应该不一样的。
实际上：& arr 表示的是数组的地址，而不是数组首元素的地址。（细细体会一下）
本例中& arr 的类型是： int(*)[10] ，是一种数组指针类型
数组的地址 + 1，跳过整个数组的大小，所以 & arr + 1 相对于 & arr 的差值是40.
*/ 