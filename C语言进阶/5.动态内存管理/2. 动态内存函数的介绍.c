#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>

/********************************* 2.1 malloc和free *******************************
C语言提供了一个动态内存开辟的函数：
	void* malloc (size_t size);

这个函数向内存申请一块连续可用的空间，并返回指向这块空间的指针。
	・如果开辟成功，则返回一个指向开辟好空间的指针。
	・如果开辟失败，则返回一个NULL指针，因此malloc的返回值一定要做检查。
	・返回值的类型是 void* ，所以malloc函数并不知道开辟空间的类型，具体在使用的时候使用者自己来决定。
	・如果参数 size 为0，malloc的行为是标准是未定义的，取决于编译器。

C语言提供了另外一个函数free，专门是用来做动态内存的释放和回收的，函数原型如下：
	void free (void* ptr);
	
free函数用来释放动态开辟的内存。
	・如果参数 ptr 指向的空间不是动态开辟的，那free函数的行为是未定义的。
	・如果参数 ptr 是NULL指针，则函数什么事都不做

	
	malloc和free都声明在 stdlib.h 头文件中。
	
*/


	//int main()
	//{
	//	//向内存申请10个整形的空间
	//	int* p = (int*)malloc(10 * sizeof(int));
	//	if (p == NULL)
	//	{
	//		//打印错误原因的一个方式
	//		printf("%s\n", strerror(errno));
	//	}
	//	else
	//	{
	//		//正常使用空间
	//		int i = 0;
	//		for (i = 0; i < 10; i++)
	//		{
	//			*(p + i) = i;
	//
	//		}
	//		for (i = 0; i < 10; i++)
	//		{
	//			printf("%d ", *(p + i));
	//
	//		}
	//	}
	//	//当动态申请的空间不再使用的时候
	//	//就应该还给操作系统
	//	free(p);
	//	p = NULL;//避免p成为野指针
	//	return 0;
	//}



/********************************* 2.2 calloc *******************************
C语言还提供了一个函数叫 calloc ， calloc 函数也用来动态内存分配。原型如下：
	void* calloc (size_t num, size_t size);

	・函数的功能是为 num 个大小为 size 的元素开辟一块空间，并且把空间的每个字节初始化为0。
	・与函数 malloc 的区别只在于 calloc 会在返回地址之前把申请的空间的每个字节初始化为全0

*/

//int main()
//{
//	int* p = (int *)calloc(10, sizeof(int));
//	if (p == NULL)
//	{
//		printf("%s\n", strerror(errno));
//	}
//	else
//	{
//		//正常使用空间
//		int i = 0;
//		for (i = 0; i < 10; i++)
//		{
//			*(p + i) = i;
//
//		}
//		for (i = 0; i < 10; i++)
//		{
//			printf("%d ", *(p + i));
//
//		}
//	}
//	//释放空间
//	free(p);
//	p = NULL;
//	return 0;
//}

/********************************* 2.3 realloc *******************************
・realloc函数的出现让动态内存管理更加灵活。
・有时会我们发现过去申请的空间太小了，有时候我们又会觉得申请的空间过大了，那为了合理的时
  候内存，我们一定会对内存的大小做灵活的调整。那 realloc 函数就可以做到对动态开辟内存大小的调整。

  函数原型如下：
void* realloc (void* ptr, size_t size);

・ptr 是要调整的内存地址
・size 调整之后新大小
・返回值为调整之后的内存起始位置。
・这个函数调整原内存空间大小的基础上，还会将原来内存中的数据移动到 新 的空间。
・realloc在调整内存空间的是存在两种情况：
	情况1：原有空间之后有足够大的空间
	情况2：原有空间之后没有足够大的空间
		情况1
		当是情况1 的时候，要扩展内存就直接原有内存之后直接追加空间，原来空间的数据不发生变化。
		情况2
		当是情况2 的时候，原有空间之后没有足够多的空间时，扩展的方法是：在堆空间上另找一个合适大小
		的连续空间来使用。这样函数返回的是一个新的内存地址。
		由于上述的两种情况，realloc函数的使用就要注意一些。
*/

//int main()
//{
//	int* p = (int*)malloc(20);
//	if (p == NULL)
//	{
//		printf("%s\n", strerror(errno));
//	}
//	else
//	{
//		int i = 0;
//		for (i = 0; i < 5; i++)
//		{
//			*(p + i) = i;
//		}
//	}
//	//假设20个字节不够，想用40个字节，就可以用realloc函数
//
//	//1.如果p指向的空间之后有足够的内存空间可以追加则直接追加后返回p
//	//2.如果p指向的空间之后没有足够的内存空间可以追加，则realloc函数会重新找一个新的内存区域
//	//  开辟一块满足需求的空间并且把原来内存中的数据拷贝回来释放旧的内存空间最后返回新开辟的内存空间地址 
//	//3.得用一个新的变量来接收realloc函数的返回值 
//	int* ptr = (int*)realloc(p, 40);
//	if (ptr != NULL)
//	{
//		p = ptr;
//		int i;
//		for (i = 5; i < 10; i++)
//		{
//			*(p + i) = i;
//		}
//		for (i = 0; i < 10; i++)
//		{
//			printf("%d ", *(p + i));
//		}
//	}
//	//释放空间
//	free(p);
//	p = NULL;
//	return 0;
//}

//realloc可以实现malloc函数功能 -- 直接开辟空间
//int main()
//{
//	int* p = (int*)realloc(NULL,40);//malloc(40)
//	if (p == NULL)
//	{
//		printf("%s\n", strerror(errno));
//	}
//	return 0;
//}
